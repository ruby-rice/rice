.. _pointers:

Pointers
========
C++ makes heavy use of pointers. In general, Rice hides pointers from end-users by wrapping pointer to C++ objects as a Ruby objects.

However, this rule does not always hold true. As described in the :ref:`type_mapping` section, some pointers point to:

* Fundamental types (example, ``int*``)
* Array of objects (example, ``int[]`` or ``MyClass[]``)
* Array of pointers (example ``int**`` or ``MyClass**``)

In these case, Rice uses ``Pointer<T>`` and :ref:`Buffer\<T\> <buffers>` Ruby classes to allow these pointers to be manipulated from Ruby code. In some cases these classes can be auto generated by Rice and in others you must tell Rice to generate them. These cases are explained below.

The ``Pointer<T>`` classes have no functionality - there are no methods defined on them. However, they can be passed to a C++ API that takes a pointer.

In contrast, ``Buffer<T>`` classes allow Ruby to manipulate the data pointed to by a C++ pointer. In addition, they can create new C++ pointers from Ruby objects.

.. _pointer_fundamental_types:

Fundamental Types
-----------------
It is common for C and C++ APIs to take pointers to blocks of memory consisting of fundamental types like unsigned chars. For example, the OpenCV library includes an API to create a ``Mat`` instance like this:

.. code-block:: cpp

    Matrix(int rows, int columns, void uint8_t* data)

``data`` is a pointer to a buffer consisting of uint_8 values.

Rice automatically detects these types of pointers and :doc:`generates <../types/naming>` Pointer and Buffer Ruby classes. For example, for a pointer to an int, ``int*``, Rice will create the Ruby classes  ``Rice::Pointer≺int≻`` and ``Rice::Buffer≺int≻``.

.. _pointer_array_of_objects:

Array of Objects
----------------
C++ APIs can also take a pointer to an array of objects. For example:

.. code-block:: cpp

  Matrix Matrix::operator()(const Range* ranges) const

This code creates a view onto an existing Matrix based on an array of ``Range`` objects. The length of the array is equal to the Matrix's number of dimensions.

Rice cannot distinguish this case from a normal pointer, thus you must tell it that ranges is a pointer to an array of objects. This is done using the ``ArgBuffer`` class:

.. code-block:: cpp

    Data_Type<Matrix> rb_cMatrix =
      .define_method("call", &Matrix::operator(), ArgBuffer("ranges"));

If a C++ method or function returns a buffer then you must tell Rice that by using the ``ReturnBuffer`` class:

.. code-block:: cpp

  Range* Matrix::ranges(const int row)

    Data_Type<Matrix> rb_cMatrix =
      .define_method("call", &Matrix::operator(), ReturnBuffer());

.. _pointer_array_of_pointers:

Array of Pointers
-----------------
The above example also works with an array of pointers. In that case:

.. code-block:: cpp

  Matrix Matrix::operator()(const Range** ranges) const

Notice the ``ranges`` parameter is now a ``**`` - or an array of pointers.

Rice automatically detects these types of pointers and :doc:`generates <../types/naming>` Pointer and Buffer Ruby classes. For example, for a pointer to an int, ``int**``, Rice will create the Ruby classes  ``Rice::Pointer≺int∗≻`` and ``Rice::Buffer≺int∗≻``.




